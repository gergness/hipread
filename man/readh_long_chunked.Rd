% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/readh_chunked.R
\name{readh_long_chunked}
\alias{readh_long_chunked}
\title{Read a hierarchical data file to long format, in chunks}
\usage{
readh_long_chunked(file, callback, chunk_size, var_names, var_types, rt_start,
  rt_width, var_pos_info, var_opts = NULL, skip = 0, encoding = "UTF-8",
  compression = NULL, progress = show_progress())
}
\arguments{
\item{file}{A filename}

\item{callback}{A \code{\link{callback}} function, allowing you to perform a
function on each chunk.}

\item{chunk_size}{The size of the chunks that will be read as a
single unit (defaults to 10000)}

\item{var_names}{A character vector of names for the variables}

\item{var_types}{A character vector of types for the variables. Allowed
types are \code{"character"}, \code{"double"} and \code{"integer"}.}

\item{rt_start}{An integer indicating the start position of the rectype
variable (1 indicates the first character)}

\item{rt_width}{An integer indicating the width of the rectype variable,
if there's only one record type, this width can be 0.}

\item{var_pos_info}{A list of fixed width file definitions by rectype,
if there's only one rectype, no name is required, otherwise the name
indicates the value for the rectype variable that indicates the row
is this rectype. Each of these lists must contain a list with equal
length vectors of \code{start} to indicate the starting positions starting
at 1, \code{width} to indicate the widths, and \code{var_pos} which indicates
what order in the data.frame the variable is located (again starting
at 1).}

\item{var_opts}{A vector of lists with variable specific options. For
string variables, a logical indicator named \code{trim_ws} is allowed
(if missing it defaults to \code{TRUE}) and for double variables an
integer named \code{imp_dec} indicating the number of implicit decimals
in the variable (defaults to 0).}

\item{skip}{Number of lines to skip at the start of the data (defaluts to 0).}

\item{encoding}{(Defaults to UTF-8) A string indicating what encoding to use
when reading the data, but like readr, the data will always be converted to
UTF-8 once it is imported. Note that UTF-16 and UTF-32 are not supported for
non-character columns.}

\item{compression}{If \code{NULL}, guesses the compression from the
file extension (if extension is "gz" uses gzip, otherwise
treats as plain text), can specify it with a string ("txt"
indicates plain text and "gz" for gzip).}

\item{progress}{A logical indicating whether progress should be
displayed on the screen, defaults to showing progress unless
the current context is non-interactive or in a knitr document or
if the user has turned off readr's progress by default using
the option \code{options("readr.show_progress")}.}
}
\value{
Depends on the type of \code{\link{callback}} function you use
}
\description{
Analagous to \code{\link[readr:read_fwf]{readr::read_fwf()}}, but with chunks, and allowing for
hierarchical fixed width data files (where the data file has rows of
different record types, each with their own variables and column
specifications). Reads the data into "long" format, meaning that
there is one row per observation, and variables that don't apply to
the current observation receive missing values.
}
\examples{
# Read in a data, filtering out hhnum == "002"
data <- readh_long_chunked(
  hipread_example("test-basic.dat"),
  HipDataFrameCallback$new(function(x, pos) x[x$hhnum != "002", ]),
  4,
  c("rt", "hhnum", "hh_char", "hh_dbl", "hh_impdbl", "pernum", "per_dbl", "per_mix"),
  c("character", "character", "character", "double", "double", "integer", "double", "character"),
  1,
  1,
  list(
    H = list(
      start = c(1, 2, 5, 8, 11),
      width = c(1, 3, 3, 3, 2),
      var_pos = c(1, 2, 3, 4, 5)
    ),
    P = list(
      start = c(1, 2, 5, 6, 9),
      width = c(1, 3, 1, 3, 1),
      var_pos = c(1, 2, 6, 7, 8)
    )
  ),
  list(
    list(trim_ws = TRUE),
    list(trim_ws = FALSE),
    list(trim_ws = TRUE),
    list(imp_dec = 0L),
    list(imp_dec = 1L),
    list(),
    list(imp_dec = 0L),
    list(trim_ws = TRUE)
  )
)
}
